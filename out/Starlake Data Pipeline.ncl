# DO NOT EDIT
# This file was automatically generated using json-schema-to-nickel
let js2n
  = import "../lib/main.ncl"
  in
let rec refs_
    = {
      "definitions.AccessControlEntryV1" =
        {
            grants
              | Array (
                std.contract.Sequence
                  [
                    refs_."definitions.ConvertibleToString",
                    std.contract.any_of [ js2n.Null, Bool, Number, String ]
                  ]
              )
              | doc m%"
                user / groups / service accounts to which this security level is applied.
                ex : user:me@mycompany.com,group:group@mycompany.com,serviceAccount:mysa@google-accounts.com
              "%,
            name
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "TODO"
              | optional,
            role
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "This role to give to the granted users",
            ..
          },
      "definitions.AccessPoliciesV1" =
        {
            apply
              | Bool
              | doc "Should access policies be enforced ?"
              | optional,
            database
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "GCP Project id. Required if apply is true."
              | optional,
            location
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "GCP project location. Required if apply is true."
              | optional,
            taxonomy
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "Taxonomy name. Required if apply is true."
              | optional,
            ..
          },
      "definitions.AllSinksV1" =
        {
            clustering
              | Array (
                std.contract.Sequence
                  [
                    refs_."definitions.ConvertibleToString",
                    std.contract.any_of [ js2n.Null, Bool, Number, String ]
                  ]
              )
              | doc "FS or BQ: List of attributes to use for clustering"
              | optional,
            coalesce
              | Bool
              | doc "When outputting files, should we coalesce it to a single file. Useful when CSV is the output format."
              | optional,
            connectionRef
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "JDBC: Connection String"
              | optional,
            days
              | Number
              | doc "BQ: Number of days before this table is set as expired and deleted. Never by default."
              | optional,
            enableRefresh
              | Bool
              | doc "BQ: Enable automatic refresh of materialized view ? false by default."
              | optional,
            extension
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "FS: File extension"
              | optional,
            format
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "FS: File format"
              | optional,
            id
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "ES: Attribute to use as id of the document. Generated by Elasticsearch if not specified."
              | optional,
            materializedView
              | refs_."definitions.Materialization"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "Should we materialize as a table or as a view when saving the results ? TABLE by default."
              | optional,
            options
              | refs_."definitions.MapString"
              | { _ | Dyn }
              | doc "spark  options to use"
              | optional,
            partition
              | Array String
              | doc "FS or BQ: List of partition attributes"
              | optional,
            path
              | String
              | doc "Optional path attribute if you want to save the file outside of the default location (datasets folder)"
              | optional,
            refreshIntervalMs
              | Number
              | doc "BQ: Refresh interval in milliseconds. Default to BigQuery default value"
              | optional,
            requirePartitionFilter
              | Bool
              | doc "BQ: Should be require a partition filter on every request ? No by default."
              | optional,
            sharding
              | Array (
                std.contract.Sequence
                  [
                    refs_."definitions.ConvertibleToString",
                    std.contract.any_of [ js2n.Null, Bool, Number, String ]
                  ]
              )
              | doc "columns to use for sharding. table will be named table_{sharding(0)}_{sharding(1)}"
              | optional,
            ..
          },
      "definitions.AppConfigV1" =
        {
            accessPolicies
              | refs_."definitions.AccessPoliciesV1"
              | { _ | Dyn }
              | doc "Access policies configuration"
              | optional,
            archive
              | Bool
              | doc "Should ingested files be archived after ingestion ?"
              | optional,
            archiveTable | Bool | doc "TODO" | optional,
            archiveTablePattern
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "TODO"
              | optional,
            area
              | refs_."definitions.AreaV1"
              | { _ | Dyn }
              | doc "stage, ingesting ... areas configuration"
              | optional,
            audit | refs_."definitions.AuditV1" | { _ | Dyn } | optional,
            autoExportSchema | Bool | doc "TODO" | optional,
            connectionRef
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "Default connection to use when loading / transforming data"
              | optional,
            connections
              | refs_."definitions.MapConnectionV1"
              | { _ | Dyn }
              | doc "Connections configurations"
              | optional,
            createSchemaIfNotExists | Bool | doc "TODO" | optional,
            csvOutput
              | Bool
              | doc "output files in CSV format ? Default is false"
              | optional,
            csvOutputExt
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "CSV file extension when csvOutput is true. Default is .csv"
              | optional,
            dagRef
              | refs_."definitions.DagRefV1"
              | { _ | Dyn }
              | doc "Default connection to use when loading / transforming data"
              | optional,
            dags
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "DAG generation config folder. metadata/dags by default"
              | optional,
            database
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "Default target database (projectId in GCP). May be also set using the SL_DATABASE environment variable"
              | optional,
            datasets
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "When using filesystem storage, default path to store the datasets"
              | optional,
            defaultAuditWriteFormat
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "Default write format in Spark for audit records. parquet is the default"
              | optional,
            defaultRejectedWriteFormat
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "Default write format in Spark for rejected records. parquet is the default"
              | optional,
            defaultWriteFormat
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "Default write format in Spark. parquet is the default"
              | optional,
            dsvOptions
              | refs_."definitions.MapString"
              | { _ | Dyn }
              | doc "DSV ingestion extra options"
              | optional,
            duckDbEnableExternalAccess
              | Bool
              | doc "Allow DuckDB to load / Save data from / to external sources. Default to true"
              | optional,
            duckdbExtensions
              | String
              | doc "Comma separated list of duckdb extensions to load. Default is spatial, json, httpfs"
              | optional,
            duckdbMode | Bool | doc "is duckdb mode active" | optional,
            duckdbPath
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "Where to store duckdb files if not using default"
              | optional,
            emptyIsNull
              | Bool
              | doc "Should empty strings be considered as null values ?"
              | optional,
            env
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "Default environment to use. May be also set using the SL_ENV environment variable"
              | optional,
            expectations
              | refs_."definitions.ExpectationsConfigV1"
              | { _ | Dyn }
              | doc "Expectations configuration"
              | optional,
            extra | {  .. } | doc "Map of string" | optional,
            forceDomainPattern
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "reserved"
              | optional,
            forceHalt
              | Bool
              | doc "Force application to stop even when there is some pending thread."
              | optional,
            forceJobPattern
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "reserved"
              | optional,
            forceTablePattern
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "reserved"
              | optional,
            forceTaskPattern
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "reserved"
              | optional,
            forceViewPattern
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "reserved"
              | optional,
            grouped
              | Bool
              | doc "Should we load of the files to be stored in the same table in a single task or one by one ?"
              | optional,
            groupedMax
              | std.number.Integer
              | doc "Maximum number of files to be stored in the same table in a single task"
              | optional,
            hadoop
              | refs_."definitions.MapString"
              | { _ | Dyn }
              | doc "Hadoop configuration if applicable"
              | optional,
            hiveInTest
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "Internal use only"
              | optional,
            http
              | refs_."definitions.HttpV1"
              | { _ | Dyn }
              | doc "TODO"
              | optional,
            incoming
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "Incoming folder to use during autoload"
              | optional,
            internal
              | refs_."definitions.InternalV1"
              | { _ | Dyn }
              | doc "Internal configuration"
              | optional,
            jdbcEngines
              | refs_."definitions.MapJdbcEngineV1"
              | { _ | Dyn }
              | doc "JDBC engine configurations"
              | optional,
            jobIdEnvName
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "TODO"
              | optional,
            kafka
              | refs_."definitions.KafkaConfigV1"
              | { _ | Dyn }
              | doc "TODO"
              | optional,
            loadConnectionRef
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "Default connection to use when loading / transforming data"
              | optional,
            loadStrategyClass
              | std.contract.any_of
                [
                  js2n.Const "ai.starlake.job.load.IngestionNameStrategy",
                  js2n.Const "ai.starlake.job.load.IngestionTimeStrategy"
                ]
              | refs_."definitions.ConvertibleToString"
              | doc m%"
                In what order should the files for a same table be loaded ? By time (default) or by or name ?
                
              "%
              | optional,
            loader
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "Default loader to use when none is specified in the schema. Valid values are 'spark' or 'native'. Default is 'spark'"
              | optional,
            lock | refs_."definitions.LockV1" | { _ | Dyn } | optional,
            longJobTimeoutMs | std.number.Integer | doc "TODO" | optional,
            maxInteractiveRecords | std.number.Integer | doc "TODO" | optional,
            maxParCopy | std.number.Integer | doc "" | optional,
            maxParTask
              | std.number.Integer
              | doc "How many job to run simultaneously in dev mode (experimental)"
              | optional,
            metadata
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "default metadata folder name. May be also set using the SL_METADATA environment variable"
              | optional,
            metrics | refs_."definitions.MetricsV1" | { _ | Dyn } | optional,
            privacy
              | refs_."definitions.PrivacyV1"
              | { _ | Dyn }
              | doc "Privacy algorithms"
              | optional,
            privacyOnly
              | Bool
              | doc "Only generate privacy tasks. Reserved for internal use"
              | optional,
            refs
              | Array (
                std.contract.Sequence [ refs_."definitions.RefV1", { _ | Dyn } ]
              )
              | doc "TODO"
              | optional,
            rejectAllOnError
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "Should we reject all records when an error occurs ? Default is false"
              | optional,
            rejectMaxRecords
              | std.number.Integer
              | doc "Maximum number of records to reject when an error occurs. Default is 100"
              | optional,
            root
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "Root folder for the application. May be also set using the SL_ROOT environment variable"
              | optional,
            rowValidatorClass
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc ""
              | optional,
            scd2EndTimestamp
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "TODO"
              | optional,
            scd2StartTimestamp
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "TODO"
              | optional,
            schedulePresets
              | refs_."definitions.MapString"
              | { _ | Dyn }
              | doc "Default connection to use when loading / transforming data"
              | optional,
            sessionDurationServe
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "reserved"
              | optional,
            shortJobTimeoutMs | std.number.Integer | doc "TODO" | optional,
            sinkReplayToFile
              | Bool
              | doc "Should invalid records be stored in a replay file ?"
              | optional,
            spark | {  .. } | doc "Map of string" | optional,
            sparkScheduling
              | refs_."definitions.SparkSchedulingV1"
              | { _ | Dyn }
              | doc "Spark Job scheduling configuration"
              | optional,
            sqlParameterPattern
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "Pattern to use to replace parameters in SQL queries in addition to the jinja syntax {{param}}. Default is ${param}"
              | optional,
            tenant
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "reserved"
              | optional,
            testCsvNullString
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "null string value in tests"
              | optional,
            tests
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "Path to tests folder. Default is ${metadata}/tests"
              | optional,
            timezone
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "TODO"
              | optional,
            transformConnectionRef
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "Default connection to use when loading / transforming data"
              | optional,
            treeValidatorClass
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc ""
              | optional,
            udfs
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "Coma separated list of UDF to register in Spark jobs. May be also set using the SL_UDFS environment variable"
              | optional,
            useLocalFileSystem
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "reserved"
              | optional,
            validateOnLoad
              | Bool
              | doc "Validate the YAML file when loading it. If set to true fails on any error"
              | optional,
            version
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "TODO"
              | optional,
            writeStrategies
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "Location where are located user defined write strategies; Default is ${metadata}/write-strategies"
              | optional,
            ..
          },
      "definitions.AreaV1" =
        {
            archive
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "Files that have been ingested are moved to this folder if SL_ARCHIVE is set to true."
              | optional,
            hiveDatabase
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc ""
              | optional,
            incoming
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "Files are read from  this folder for ingestion by the \"import\" command."
              | optional,
            ingesting
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "Files that are being ingested are moved to this folder."
              | optional,
            replay
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "Invalid records are stored in this folder in source format when SL_SINK_REPLAY_TO_FILE is set to true."
              | optional,
            stage
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "Files recognized by the extensions property are moved to this folder for ingestion by the \"import\" command."
              | optional,
            unresolved
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "Files that cannot be ingested (do not match by any table pattern) are moved to this folder."
              | optional,
            ..
          },
      "definitions.AttributeDescV1" =
        {
            accessPolicy
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "Access policy to apply to this column"
              | optional,
            comment
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "Column description"
              | optional,
            name
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "Column name",
            type
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "Column Type"
              | optional,
            ..
          },
      "definitions.AttributeV1" =
        {
            accessPolicy
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "Policy tag to assign to this attribute. Used for column level security"
              | optional,
            array | Bool | doc "Is it an array ?" | optional,
            attributes
              | Array (std.contract.Sequence [ js2n.Always, { _ | Dyn } ])
              | doc "List of sub-attributes (valid for JSON and XML files only)"
              | optional,
            comment
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "free text for attribute description"
              | optional,
            "default"
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "Default value for this attribute when it is not present."
              | optional,
            foreignKey
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "If this attribute is a foreign key, reference to [domain.]table[.attribute]"
              | optional,
            ignore
              | Bool
              | doc "Should this attribute be ignored on ingestion. Default to false"
              | optional,
            metricType
              | refs_."definitions.MetricTypeV1"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "If present, what kind of stat should be computed for this field"
              | optional,
            name
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "Attribute name as defined in the source dataset and as received in the file",
            position | refs_."definitions.PositionV1" | { _ | Dyn } | optional,
            privacy
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "Should this attribute be applied a privacy transformation at ingestion time"
              | optional,
            rename
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "If present, the attribute is renamed with this name"
              | optional,
            required
              | Bool
              | doc "Should this attribute always be present in the source. Default to true."
              | optional,
            sample
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "Sample data for this attribute"
              | optional,
            script
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "Scripted field : SQL request on renamed column"
              | optional,
            tags
              | Array (
                std.contract.Sequence
                  [
                    refs_."definitions.ConvertibleToString",
                    std.contract.any_of [ js2n.Null, Bool, Number, String ]
                  ]
              )
              | doc "Tags associated with this attribute"
              | optional,
            trim
              | refs_."definitions.TrimV1"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | optional,
            type
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "semantic type of the attribute. Default to string"
              | optional,
            ..
          },
      "definitions.AuditV1" =
        {
            active | Bool | doc "Output table description" | optional,
            database
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "Dataset Name in output Area (Will be the Table name in Hive & BigQuery)"
              | optional,
            domain
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | optional,
            domainExpectation
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | optional,
            domainRejected
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | optional,
            maxErrors
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "Output domain in output Area (Will be the Database name in Hive or Dataset in BigQuery)"
              | optional,
            path
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "Main SQL request to execute (do not forget to prefix table names with the database name to avoid conflicts)"
              | optional,
            sink
              | refs_."definitions.AllSinksV1"
              | { _ | Dyn }
              | doc "Output Database (refer to a project id in BigQuery). Default to SL_DATABASE env var if set."
              | optional,
            sql
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "TODO"
              | optional,
            ..
          },
      "definitions.AutoJobDescV1" =
        {
            comment
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "Optional description."
              | optional,
            "default"
              | refs_."definitions.AutoTaskDescV1"
              | { _ | Dyn }
              | doc "Default task properties to apply to all tasks defined in tasks section and in included files"
              | optional,
            name
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "Optional name. If not specified, the name of the file without the extension is used."
              | optional,
            tasks
              | Array (
                std.contract.Sequence
                  [ refs_."definitions.AutoTaskDescV1", { _ | Dyn } ]
              )
              | optional,
            ..
          },
      "definitions.AutoTaskDescV1" =
        {
            acl
              | Array (
                std.contract.Sequence
                  [ refs_."definitions.AccessControlEntryV1", { _ | Dyn } ]
              )
              | doc "Map of rolename -> List[Users]."
              | optional,
            attributes
              | Array (
                std.contract.Sequence
                  [ refs_."definitions.AttributeDescV1", { _ | Dyn } ]
              )
              | doc "Attributes comments and access policies"
              | optional,
            comment
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "Output table description"
              | optional,
            connectionRef
              | String
              | doc "Used when the default connection ref present in the application.sl.yml file is not the one to use to run the SQL request for this task."
              | optional,
            dagRef
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "Cron expression to use for this domain/table"
              | optional,
            database
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "Output Database (refer to a project id in BigQuery). Default to SL_DATABASE env var if set."
              | optional,
            domain
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "Output domain in output Area (Will be the Database name in Hive or Dataset in BigQuery)"
              | optional,
            expectations
              | Array (
                std.contract.Sequence
                  [ refs_."definitions.ExpectationItemV1", { _ | Dyn } ]
              )
              | doc "Expectations to check after Load / Transform has succeeded"
              | optional,
            freshness
              | refs_."definitions.FreshnessV1"
              | { _ | Dyn }
              | doc "Configure freshness checks on the output table"
              | optional,
            name
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "Main SQL request to execute (do not forget to prefix table names with the database name to avoid conflicts)"
              | optional,
            parseSQL
              | Bool
              | doc "Should we parse this SQL make it update the table according to write strategy or just execute it ?"
              | optional,
            partition
              | Array (
                std.contract.Sequence
                  [
                    refs_."definitions.ConvertibleToString",
                    std.contract.any_of [ js2n.Null, Bool, Number, String ]
                  ]
              )
              | doc "List of columns used for partitioning the output."
              | optional,
            postsql
              | Array (
                std.contract.Sequence
                  [
                    refs_."definitions.ConvertibleToString",
                    std.contract.any_of [ js2n.Null, Bool, Number, String ]
                  ]
              )
              | doc "List of SQL requests to executed after the main SQL request is run"
              | optional,
            presql
              | Array (
                std.contract.Sequence
                  [
                    refs_."definitions.ConvertibleToString",
                    std.contract.any_of [ js2n.Null, Bool, Number, String ]
                  ]
              )
              | doc "List of SQL requests to executed before the main SQL request is run"
              | optional,
            python
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "Python script URI to execute instead of the SQL request"
              | optional,
            rls
              | Array (
                std.contract.Sequence
                  [ refs_."definitions.RowLevelSecurityV1", { _ | Dyn } ]
              )
              | optional,
            schedule
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "Cron expression to use for this task"
              | optional,
            sink | refs_."definitions.AllSinksV1" | { _ | Dyn } | optional,
            sql
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "Main SQL request to execute (do not forget to prefix table names with the database name to avoid conflicts)"
              | optional,
            streams
              | Array (
                std.contract.Sequence
                  [
                    refs_."definitions.ConvertibleToString",
                    std.contract.any_of [ js2n.Null, Bool, Number, String ]
                  ]
              )
              | doc "attach streams to task (Snowflake only)"
              | optional,
            table
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "Dataset Name in output Area (Will be the Table name in Hive & BigQuery)"
              | optional,
            tags
              | Array (
                std.contract.Sequence
                  [
                    refs_."definitions.ConvertibleToString",
                    std.contract.any_of [ js2n.Null, Bool, Number, String ]
                  ]
              )
              | doc "Set of string to attach to the output table"
              | optional,
            taskTimeoutMs
              | std.number.Integer
              | doc "Number of milliseconds before a communication timeout."
              | optional,
            writeStrategy
              | refs_."definitions.WriteStrategyV1"
              | { _ | Dyn }
              | doc "TODO"
              | optional,
            ..
          },
      "definitions.ConnectionV1" =
        {
            loader
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "Loader we should use with this connection. Superseded by the loader defined in the file metadata"
              | optional,
            options
              | refs_."definitions.MapString"
              | { _ | Dyn }
              | doc "Connection options"
              | optional,
            quote
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "Set only if you want to use the Spark engine"
              | optional,
            separator
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "Set only if you want to use the Spark engine"
              | optional,
            sparkFormat
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "Set only if you want to use the Spark engine"
              | optional,
            type
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "aka jdbc, bigquery, snowflake, redshift ...",
            ..
          },
      "definitions.ConvertibleToString" =
        std.contract.any_of
            [ String, Bool, Number, std.number.Integer, js2n.Null ],
      "definitions.DagGenerationConfigV1" =
        {
            comment
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "Dag config description"
              | optional,
            filename
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "{schedule}, {domain}, {table} in the file name are used for DAG generation purposes",
            options
              | refs_."definitions.MapString"
              | { _ | Dyn }
              | doc "DAG generation options"
              | optional,
            template
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "Dag template to use for this config. Usually a .py.j2 file",
            ..
          },
      "definitions.DagRefV1" =
        {
            load
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "TODO"
              | optional,
            transform
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "TODO"
              | optional,
            ..
          },
      "definitions.DomainV1" =
        {
            comment
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "Domain Description (free text)"
              | optional,
            database
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "Output Database (refer to a project id in BigQuery). Default to SL_DATABASE env var if set."
              | optional,
            metadata | refs_."definitions.MetadataV1" | { _ | Dyn } | optional,
            name
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc m%"
                Domain name. Make sure you use a name that may be used as a folder name on the target storage.
                                   - When using HDFS or Cloud Storage,  files once ingested are stored in a sub-directory named after the domain name.
                                   - When used with BigQuery, files are ingested and sorted in tables under a dataset named after the domain name.
              "%
              | optional,
            rename
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "If present, the attribute is renamed with this name"
              | optional,
            tags
              | Array (
                std.contract.Sequence
                  [
                    refs_."definitions.ConvertibleToString",
                    std.contract.any_of [ js2n.Null, Bool, Number, String ]
                  ]
              )
              | doc "Set of string to attach to this domain"
              | optional,
            ..
          },
      "definitions.ExpectationItemV1" =
        {
            expect
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "When using filesystem storage, the path to the expectations file"
              | optional,
            failOnError
              | Bool
              | doc "should load / transform fail on expectation error ?"
              | optional,
            ..
          },
      "definitions.ExpectationsConfigV1" =
        {
            active | Bool | doc "should expectations be executed ?" | optional,
            failOnError
              | Bool
              | doc "should load / transform fail on expectation error ?"
              | optional,
            path
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "When using filesystem storage, the path to the expectations file"
              | optional,
            ..
          },
      "definitions.ExtractV1Base" =
        {
            connectionRef
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "With OpenAPI: connection used to reference OpenAPI spec. Supports file (local, storage) or public http url. With others, connection used to retrieve schema and then data. If not defined, fallback to application settings."
              | optional,
            sanitizeAttributeName
              | std.contract.any_of
                [ js2n.Const "ON_EXTRACT", js2n.Const "ON_LOAD" ]
              | optional,
            ..
          },
      "definitions.FormatV1" =
        std.contract.Sequence
            [
              js2n.OneOf
                [
                  js2n.Const "DATAFRAME",
                  js2n.Const "DSV",
                  js2n.Const "POSITION",
                  js2n.Const "JSON",
                  js2n.Const "JSON_ARRAY",
                  js2n.Const "JSON_FLAT",
                  js2n.Const "XML",
                  js2n.Const "TEXT_XML",
                  js2n.Const "KAFKA",
                  js2n.Const "KAFKASTREAM",
                  js2n.Const "GENERIC",
                  js2n.Const "PARQUET"
                ],
              refs_."definitions.ConvertibleToString",
              std.contract.any_of [ js2n.Null, Bool, Number, String ]
            ],
      "definitions.FreshnessV1" =
        {
            error
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "How old may be the data before an error is raised. Use syntax like '3 day' or '2 hour' or '30 minute'"
              | optional,
            warn
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "How old may be the data before a warning is raised. Use syntax like '3 day' or '2 hour' or '30 minute'"
              | optional,
            ..
          },
      "definitions.HttpV1" =
        {
            interface
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "TODO"
              | optional,
            port | std.number.Integer | doc "TODO" | optional,
            ..
          },
      "definitions.InputRefV1" =
        {
            database
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "Database pattern to match, none if any database"
              | optional,
            domain
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "Domain pattern to match, none if any domain match"
              | optional,
            table
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "Table pattern to match",
            ..
          },
      "definitions.InternalV1" =
        {
            bqAuditSaveInBatchMode | Bool | doc "TODO" | optional,
            cacheStorageLevel
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc m%"
                How the RDD are cached. Default is MEMORY_AND_DISK_SER.
                Available options are (https://spark.apache.org/docs/latest/api/java/index.html?org/apache/spark/storage/StorageLevel.html):
                - MEMORY_ONLY
                - MEMORY_AND_DISK
                - MEMORY_ONLY_SER
                - MEMORY_AND_DISK_SER
                - DISK_ONLY
                - OFF_HEAP
              "%
              | optional,
            intermediateBigqueryFormat
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc m%"
                May be parquet or ORC. Default is parquet. Used for BigQuery intermediate storage. Use ORC for for JSON files to keep the original data structure.
                https://stackoverflow.com/questions/53674838/spark-writing-parquet-arraystring-converts-to-a-different-datatype-when-loadin
              "%
              | optional,
            substituteVars
              | Bool
              | doc "Internal use. Do not modify."
              | optional,
            temporaryGcsBucket
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "The GCS bucket that temporarily holds the data before it is loaded to BigQuery."
              | optional,
            ..
          },
      "definitions.JDBCSchemaBase" =
        {
            catalog
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "Optional catalog name in the source database. Scope: Schema and Data extraction."
              | optional,
            columnRemarks
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "Query template used to retrieve all columns' remark of a table. Available variables: catalog, schema, table. Scope: Schema extraction."
              | optional,
            connectionOptions
              | refs_."definitions.MapString"
              | { _ | Dyn }
              | doc "Options to set on data connection. Scope: Data extraction."
              | optional,
            fetchSize
              | std.number.Integer
              | doc "Number of rows to be fetched from the database when additional rows are needed. By default, most JDBC drivers use a fetch size of 10, so if you are reading 1000 objects, increasing the fetch size to 256 can significantly reduce the time required to fetch the query's results. The optimal fetch size is not always obvious. Scope: Data extraction."
              | optional,
            fullExport
              | Bool
              | doc "Define if we should fetch the entire table's or not. If not, maximum value of partitionColumn seen during last extraction is used in order to fetch incremental data. Scope: Data extraction."
              | optional,
            numPartitions
              | std.number.Integer
              | doc "Number of data partitions to create. Scope: Data extraction."
              | optional,
            numericTrim
              | refs_."definitions.TrimV1"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "Trim strategies applied to numeric fields set on load table's definition. Scope: Schema extraction."
              | optional,
            partitionColumn
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "Column to use in order to parallelize data extraction. Scope: Data extraction."
              | optional,
            pattern
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "Pattern template used to define load tables' file pattern. Available variables: catalog, schema, table. Scope: Schema extraction."
              | optional,
            sanitizeName
              | Bool
              | doc "Sanitize domain's name by keeping alpha numeric characters only. Scope: Schema and Data extraction."
              | optional,
            schema
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "Database schema where source tables are located. For mysql use this instead of catalog. Scope: Schema and Data extraction."
              | optional,
            stringPartitionFunc
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "SQL template used on partition column's of type String. Some implementations are already defined, see ai.starlake.extract.JdbcDbUtils.getStringPartitionFunc. Mandatory variables: col, nb_partitions. Scope: Data extraction."
              | optional,
            tableRemarks
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "Query template used to retrieve table remark. Available variables: catalog, schema, table. Scope: Schema extraction."
              | optional,
            tableTypes
              | Array (
                std.contract.Sequence
                  [
                    refs_."definitions.TableTypeV1",
                    std.contract.any_of [ js2n.Null, Bool, Number, String ]
                  ]
              )
              | doc "One or many of the predefined table types. Scope: Schema and Data extraction."
              | optional,
            template
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "Template used during schema extraction in order to generate load files (domain and tables). Scope: Schema extraction."
              | optional,
            ..
          },
      "definitions.JDBCSchemaV1" =
        std.contract.Sequence
            [
              refs_."definitions.JDBCSchemaBase",
              {
                exclude
                  | Array (
                    std.contract.Sequence
                      [
                        refs_."definitions.ConvertibleToString",
                        std.contract.any_of [ js2n.Null, Bool, Number, String ]
                      ]
                  )
                  | doc "List of tables to exclude. Applied on tables list. Scope: Schema and Data extraction."
                  | optional,
                tables
                  | Array (
                    std.contract.Sequence
                      [ refs_."definitions.JDBCTableV1", { _ | Dyn } ]
                  )
                  | doc "List of tables to extract. Scope: Schema and Data extraction."
                  | optional,
                ..
              }
            ],
      "definitions.JDBCSchemasV1" =
        std.contract.Sequence
            [
              refs_."definitions.ExtractV1Base",
              std.contract.not
                (std.contract.any_of
                  [
                    js2n.Null,
                    Bool,
                    Number,
                    String,
                    js2n.record.Required [ "openAPI" ],
                    Array Dyn
                  ]),
              {
                auditConnectionRef
                  | refs_."definitions.ConvertibleToString"
                  | std.contract.any_of [ js2n.Null, Bool, Number, String ]
                  | doc "Connection used to read/store audit from it. If not defined, fallbacks to connectionRef. Expected connection name as defined in the connections section of the application.conf file. Scope: Data extraction."
                  | optional,
                "default"
                  | refs_."definitions.JDBCSchemaBase"
                  | { _ | Dyn }
                  | doc "Configuration merged into each jdbcSchemas. Scope: Schema and Data extraction."
                  | optional,
                jdbcSchemas
                  | Array (
                    std.contract.Sequence
                      [ refs_."definitions.JDBCSchemaV1", { _ | Dyn } ]
                  )
                  | doc "Describe what to fetch from data connection. Scope: Schema and Data extraction."
                  | optional,
                output
                  | refs_."definitions.OutputV1"
                  | { _ | Dyn }
                  | doc "Override the output format of data extraction. Scope: Data extraction."
                  | optional,
                ..
              }
            ],
      "definitions.JDBCTableV1" =
        {
            columns
              | js2n.array.MinItems 1
              | Array (
                js2n.OneOf
                  [
                    std.contract.Sequence
                      [
                        refs_."definitions.ConvertibleToString",
                        std.contract.any_of [ js2n.Null, Bool, Number, String ]
                      ],
                    js2n.record.Record
                      {
                        additional = 'Some Dyn,
                        patterns = {},
                        properties =
                          {
                              name =
                                std.contract.Sequence
                                    [
                                      refs_."definitions.ConvertibleToString",
                                      std.contract.any_of
                                        [ js2n.Null, Bool, Number, String ]
                                    ],
                              rename =
                                std.contract.Sequence
                                    [
                                      refs_."definitions.ConvertibleToString",
                                      std.contract.any_of
                                        [ js2n.Null, Bool, Number, String ]
                                    ],
                            },
                        required = { name = true, },
                      }
                  ]
              )
              | doc "List of columns to extract. All columns by default."
              | optional,
            connectionOptions
              | refs_."definitions.MapString"
              | { _ | Dyn }
              | optional,
            fetchSize | std.number.Integer | optional,
            filter
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "Filter applied along data extraction. Scope: Data extraction"
              | optional,
            fullExport | Bool | optional,
            name
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "Table name. Set to '*' to extract all tables. Scope: Schema and Data extraction."
              | optional,
            numPartitions | std.number.Integer | optional,
            partitionColumn
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | optional,
            sql
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "SQL used to extract schema and data. Ignore columns attribute if set."
              | optional,
            stringPartitionFunc
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "SQL template used on partition column's of type String. Some implementations are already defined, see ai.starlake.extract.JdbcDbUtils.getStringPartitionFunc. Mandatory variables: col, nb_partitions. Scope: Data extraction."
              | optional,
            ..
          },
      "definitions.JdbcEngineV1" =
        {
            clusterBy | String | doc "TODO" | optional,
            columnRemarks | String | doc "TODO" | optional,
            partitionBy | String | doc "TODO" | optional,
            preActions | String | doc "TODO" | optional,
            quote | String | doc "TODO",
            strategyBuilder | String | doc "TODO",
            tableRemarks | String | doc "TODO" | optional,
            tables
              | refs_."definitions.MapTableDdlV1"
              | { _ | Dyn }
              | doc m%"
                List of all SQL create statements used to create audit tables for this JDBC engine.
                Tables are created only if the execution of the pingSQL statement fails
              "%,
            viewPrefix | String | doc "TODO" | optional,
            ..
          },
      "definitions.KafkaConfigV1" =
        {
            cometOffsetsMode
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "TODO"
              | optional,
            customDeserializers
              | refs_."definitions.MapString"
              | { _ | Dyn }
              | doc "TODO"
              | optional,
            serverOptions
              | refs_."definitions.MapString"
              | { _ | Dyn }
              | doc "TODO"
              | optional,
            topics
              | { _ | refs_."definitions.KafkaTopicConfigV1" }
              | doc "Map of topic configs"
              | optional,
            ..
          },
      "definitions.KafkaTopicConfigV1" =
        std.contract.any_of
            [
              js2n.Null,
              Bool,
              Number,
              String,
              {
                accessOptions
                  | refs_."definitions.MapString"
                  | { _ | Dyn }
                  | doc "TODO"
                  | optional,
                createOptions
                  | refs_."definitions.MapString"
                  | { _ | Dyn }
                  | doc "TODO"
                  | optional,
                fields
                  | Array (
                    std.contract.Sequence
                      [
                        refs_."definitions.ConvertibleToString",
                        std.contract.any_of [ js2n.Null, Bool, Number, String ]
                      ]
                  )
                  | doc "TODO"
                  | optional,
                headers
                  | {
                    _ | std.contract.Sequence
                      [ refs_."definitions.MapString", { _ | Dyn } ]
                  }
                  | doc "TODO"
                  | optional,
                maxRead | std.number.Integer | doc "TODO" | optional,
                partitions | std.number.Integer | doc "TODO" | optional,
                replicationFactor | std.number.Integer | doc "TODO" | optional,
                topicName
                  | refs_."definitions.ConvertibleToString"
                  | std.contract.any_of [ js2n.Null, Bool, Number, String ]
                  | doc "TODO"
                  | optional,
                ..
              },
              Array Dyn
            ],
      "definitions.LockV1" =
        {
            path
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "Name of the lock"
              | optional,
            pollTime
              | std.number.Integer
              | doc "TODO. Default 5 seconds"
              | optional,
            refreshTime
              | std.number.Integer
              | doc "TODO. Default 5 seconds"
              | optional,
            timeout | std.number.Integer | doc "TODO" | optional,
            ..
          },
      "definitions.MapConnectionV1" =
        {
            _ | std.contract.Sequence
              [ refs_."definitions.ConnectionV1", { _ | Dyn } ]
          },
      "definitions.MapJdbcEngineV1" =
        {
            _ | std.contract.Sequence
              [ refs_."definitions.JdbcEngineV1", { _ | Dyn } ]
          },
      "definitions.MapString" =
        {
            _ | std.contract.Sequence
              [
                refs_."definitions.ConvertibleToString",
                std.contract.any_of [ js2n.Null, Bool, Number, String ]
              ]
          },
      "definitions.MapTableDdlV1" =
        {
            _ | std.contract.Sequence
              [ refs_."definitions.TableDdlV1", { _ | Dyn } ]
          },
      "definitions.Materialization" =
        std.contract.Sequence
            [
              js2n.OneOf
                [
                  js2n.Const "TABLE",
                  js2n.Const "VIEW",
                  js2n.Const "MATERIALIZED_VIEW"
                ],
              refs_."definitions.ConvertibleToString",
              std.contract.any_of [ js2n.Null, Bool, Number, String ]
            ],
      "definitions.MergeOnV1" =
        js2n.OneOf [ js2n.Const "TARGET", js2n.Const "SOURCE_AND_TARGET" ],
      "definitions.MetadataV1" =
        {
            ack
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc m%"
                Ack extension used for each file. ".ack" if not specified.
                Files are moved to the stage folder only once a file with the same name as the source file and with this extension is present.
                To move a file without requiring an ack file to be present, set explicitly this property to the empty string value "".
              "%
              | optional,
            array
              | Bool
              | doc "Is the json stored as a single object array ? false by default. This means that by default we have on json document per line."
              | optional,
            dagRef
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "Cron expression to use for this domain/table"
              | optional,
            directory
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc m%"
                Folder on the local filesystem where incoming files are stored.
                 Typically, this folder will be scanned periodically to move the dataset to the cluster for ingestion.
                                     Files located in this folder are moved to the stage folder for ingestion by the "import" command.
              "%
              | optional,
            emptyIsNull
              | Bool
              | doc "Treat empty columns as null in DSV files. Default to false"
              | optional,
            encoding
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "UTF-8 if not specified."
              | optional,
            escape
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "escaping char '\\' by default"
              | optional,
            extensions
              | Array (
                std.contract.Sequence
                  [
                    refs_."definitions.ConvertibleToString",
                    std.contract.any_of [ js2n.Null, Bool, Number, String ]
                  ]
              )
              | doc m%"
                recognized filename extensions. json, csv, dsv, psv are recognized by default.
                Only files with these extensions will be moved to the stage folder.
              "%
              | optional,
            format
              | refs_."definitions.FormatV1"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | optional,
            freshness
              | refs_."definitions.FreshnessV1"
              | { _ | Dyn }
              | doc "Configure freshness checks on this dataset"
              | optional,
            ignore
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "Pattern to ignore or UDF to apply to ignore some lines"
              | optional,
            loader
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "Loader to use, 'spark' or 'native'. Default to 'spark' of SL_LOADER env variable is set to 'native'"
              | optional,
            multiline
              | Bool
              | doc "are json objects on a single line or multiple line ? Single by default.  false means single. false also means faster"
              | optional,
            nullValue
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "Treat a specific input string as a null value indicator"
              | optional,
            options
              | refs_."definitions.MapString"
              | { _ | Dyn }
              | doc "Options to add to the spark reader"
              | optional,
            quote
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "The String quote char, '\"' by default"
              | optional,
            schedule
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "Cron expression to use for this domain/table"
              | optional,
            separator
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "the values delimiter,  ';' by default value may be a multichar string starting from Spark3"
              | optional,
            sink | refs_."definitions.AllSinksV1" | { _ | Dyn } | optional,
            withHeader
              | Bool
              | doc "does the dataset has a header ? true by default"
              | optional,
            writeStrategy
              | refs_."definitions.WriteStrategyV1"
              | { _ | Dyn }
              | doc "TODO"
              | optional,
            ..
          },
      "definitions.MetricTypeV1" =
        std.contract.Sequence
            [
              js2n.OneOf
                [
                  js2n.Const "DISCRETE",
                  js2n.Const "CONTINUOUS",
                  js2n.Const "TEXT",
                  js2n.Const "NONE"
                ],
              refs_."definitions.ConvertibleToString",
              std.contract.any_of [ js2n.Null, Bool, Number, String ]
            ],
      "definitions.MetricsV1" =
        {
            active | Bool | doc "Should metrics be computed ?" | optional,
            discreteMaxCardinality
              | std.number.Integer
              | doc "Max number of unique values accepted for a discrete column. Default is 10"
              | optional,
            path
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "When using filesystem storage, the path to the metrics file"
              | optional,
            ..
          },
      "definitions.OpenAPIDomainV1" =
        {
            basePath
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "Common base path used to remove from path in order to generate final table name."
              | optional,
            name
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "Domain name used to group tables extracted from openAPI spec",
            routes
              | js2n.array.MinItems 1
              | Array (
                std.contract.Sequence
                  [ refs_."definitions.OpenAPIRoutesV1", { _ | Dyn } ]
              )
              | doc "Describe what to fetch from data connection. Scope: Schema and Data extraction."
              | optional,
            schemas
              | refs_."definitions.OpenAPIObjectSchemasV1"
              | { _ | Dyn }
              | doc "Describe what to fetch from data connection. Scope: Schema and Data extraction."
              | optional,
            ..
          },
      "definitions.OpenAPIObjectSchemasV1" =
        {
            exclude
              | Array (
                std.contract.Sequence
                  [
                    refs_."definitions.ConvertibleToString",
                    std.contract.any_of [ js2n.Null, Bool, Number, String ]
                  ]
              )
              | doc "List of regex used to exclude open api schemas (#/components/schemas). Defaults to []."
              | optional,
            include
              | js2n.array.MinItems 1
              | Array (
                std.contract.Sequence
                  [
                    refs_."definitions.ConvertibleToString",
                    std.contract.any_of [ js2n.Null, Bool, Number, String ]
                  ]
              )
              | doc "List of regex used to include open api schemas (#/components/schemas). Defaults to ['.*']. 'Includes' is evaluated before 'excludes'"
              | optional,
            ..
          },
      "definitions.OpenAPIRouteObjectExplosionV1" =
        {
            exclude
              | Array (
                std.contract.Sequence
                  [
                    refs_."definitions.ConvertibleToString",
                    std.contract.any_of [ js2n.Null, Bool, Number, String ]
                  ]
              )
              | doc "filter out on field path. Each field is separated by _. Default to []"
              | optional,
            on
              | std.contract.any_of
                [ js2n.Const "ALL", js2n.Const "OBJECT", js2n.Const "ARRAY" ]
              | doc "Explode route's object to more object definition. Use object's path with route path as final name. Defaults to ALL"
              | optional,
            rename
              | {
                _ | std.contract.Sequence
                  [
                    refs_."definitions.ConvertibleToString",
                    std.contract.any_of [ js2n.Null, Bool, Number, String ]
                  ]
              }
              | doc "Regex applied on object path. If matches, use the given name otherwise fallback to route_path + object path as final name"
              | optional,
            ..
          },
      "definitions.OpenAPIRoutesV1" =
        {
            as
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "Force all routes matching the pattern to be saved as the given name if they don't conflict"
              | optional,
            exclude
              | js2n.array.MinItems 1
              | Array (
                std.contract.Sequence
                  [
                    refs_."definitions.ConvertibleToString",
                    std.contract.any_of [ js2n.Null, Bool, Number, String ]
                  ]
              )
              | doc "List of regex used to excludes api path []"
              | optional,
            excludeFields
              | js2n.array.MinItems 1
              | Array (
                std.contract.Sequence
                  [
                    refs_."definitions.ConvertibleToString",
                    std.contract.any_of [ js2n.Null, Bool, Number, String ]
                  ]
              )
              | doc "List of regex used to excludes fields. Fields and their subfields are separated by _."
              | optional,
            explode
              | refs_."definitions.OpenAPIRouteObjectExplosionV1"
              | { _ | Dyn }
              | doc "Explodes on route's object and split the schema."
              | optional,
            operations
              | js2n.array.MinItems 1
              | Array (
                std.contract.any_of [ js2n.Const "GET", js2n.Const "POST" ]
              )
              | doc "List of operations to retrieve schema from. Defaults to ['GET']. Supported values are GET and POST."
              | optional,
            paths
              | js2n.array.MinItems 1
              | Array (
                std.contract.Sequence
                  [
                    refs_."definitions.ConvertibleToString",
                    std.contract.any_of [ js2n.Null, Bool, Number, String ]
                  ]
              )
              | doc "List of regex used to include open api path '.*'"
              | optional,
            ..
          },
      "definitions.OpenAPIV1" =
        {
            basePath
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "Common base path used to remove from path in order to generate final table name."
              | optional,
            domains
              | js2n.array.MinItems 1
              | Array (
                std.contract.Sequence
                  [ refs_."definitions.OpenAPIDomainV1", { _ | Dyn } ]
              )
              | doc "Describe what to fetch from data connection. Scope: Schema and Data extraction."
              | optional,
            formatTypeMapping
              | refs_."definitions.MapString"
              | { _ | Dyn }
              | doc "mapping a format used for string and the starlake attribute type"
              | optional,
            ..
          },
      "definitions.OpenAPIsV1" =
        std.contract.Sequence
            [
              refs_."definitions.ExtractV1Base",
              {
                openAPI
                  | refs_."definitions.OpenAPIV1"
                  | { _ | Dyn }
                  | doc "Describe how to extract domains and tables from OpenAPI spec",
                ..
              }
            ],
      "definitions.OpenWriteStrategyTypeV1" =
        std.contract.Sequence
            [
              js2n.OneOf
                [
                  std.contract.Sequence
                    [
                      refs_."definitions.WriteStrategyTypeBase",
                      std.contract.any_of [ js2n.Null, Bool, Number, String ]
                    ],
                  std.contract.Sequence
                    [
                      std.contract.not
                        (std.contract.Sequence
                          [
                            refs_."definitions.WriteStrategyTypeBase",
                            std.contract.any_of
                              [ js2n.Null, Bool, Number, String ]
                          ]),
                      refs_."definitions.ConvertibleToString",
                      std.contract.any_of [ js2n.Null, Bool, Number, String ]
                    ]
                ],
              refs_."definitions.ConvertibleToString",
              std.contract.any_of [ js2n.Null, Bool, Number, String ]
            ],
      "definitions.OutputRefV1" =
        {
            database
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "",
            domain
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "",
            table
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "",
            ..
          },
      "definitions.OutputV1" =
        {
            datePattern
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "Java date pattern to apply on date object. Have a look at https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html"
              | optional,
            encoding
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "Specifies encoding (charset) of saved CSV files."
              | optional,
            escape
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "Character used for escaping quotes inside an already quoted value. TODO: check if we are expecting character."
              | optional,
            nullValue
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "String representation of a null value."
              | optional,
            quote
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "Character used for escaping quoted values where the separator can be part of the value. TODO: check if we are expecting character."
              | optional,
            separator
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "Character used as a separator for each field and value. TODO: check if we are expecting character."
              | optional,
            timestampPattern
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "Java timestamp pattern to apply on timestamp object. Have a look at https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html"
              | optional,
            withHeader
              | Bool
              | doc "If true, writes the names of columns as the first line."
              | optional,
            ..
          },
      "definitions.PositionV1" =
        {
            first
              | Number
              | doc "Zero based position of the first character for this attribute",
            last
              | Number
              | doc "Zero based position of the last character to include in this attribute",
            ..
          },
      "definitions.PrimitiveTypeV1" =
        std.contract.Sequence
            [
              js2n.OneOf
                [
                  js2n.Const "string",
                  js2n.Const "long",
                  js2n.Const "int",
                  js2n.Const "short",
                  js2n.Const "double",
                  js2n.Const "boolean",
                  js2n.Const "byte",
                  js2n.Const "date",
                  js2n.Const "timestamp",
                  js2n.Const "decimal",
                  js2n.Const "variant",
                  js2n.Const "struct"
                ],
              refs_."definitions.ConvertibleToString",
              std.contract.any_of [ js2n.Null, Bool, Number, String ]
            ],
      "definitions.PrivacyV1" =
        {
            options
              | refs_."definitions.MapString"
              | { _ | Dyn }
              | doc m%"
                Privacy strategies. The following default strategies are defined by default:
                - none: Leave the data as is
                - hide: replace the data with an empty string
                - hideX("s", n): replace the string with n occurrences of the string 's'
                - md5: Redact the data using the MD5 algorithm
                - sha1: Redact the data using the SHA1 algorithm
                - sha256: Redact the data using the SHA256 algorithm
                 - sha512: Redact the data using the SHA512 algorithm
                - initials: keep only the first char of each word in the data
              "%
              | optional,
            ..
          },
      "definitions.RefV1" =
        {
            input
              | refs_."definitions.InputRefV1"
              | { _ | Dyn }
              | doc "The input table to resolve",
            output
              | refs_."definitions.OutputRefV1"
              | { _ | Dyn }
              | doc "The output table resolved with the domain and database",
            ..
          },
      "definitions.RowLevelSecurityV1" =
        {
            description
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "Description for this access policy"
              | optional,
            grants
              | Array (
                std.contract.Sequence
                  [
                    refs_."definitions.ConvertibleToString",
                    std.contract.any_of [ js2n.Null, Bool, Number, String ]
                  ]
              )
              | doc m%"
                user / groups / service accounts to which this security level is applied.
                ex : user:me@mycompany.com,group:group@mycompany.com,serviceAccount:mysa@google-accounts.com
              "%,
            name
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "This Row Level Security unique name",
            predicate
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "The condition that goes to the WHERE clause and limit the visible rows."
              | optional,
            ..
          },
      "definitions.SparkSchedulingV1" =
        {
            file
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "Scheduler filename in the metadata folder. If not set, defaults to fairscheduler.xml."
              | optional,
            maxJobs
              | std.number.Integer
              | doc "Max number of Spark jobs to run in parallel, default is 1"
              | optional,
            mode
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "This can be FIFO or FAIR, to control whether jobs within the pool queue up behind each other (the default) or share the pool’s resources fairly."
              | optional,
            poolName
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "Pool name to use for Spark jobs, default is 'default'"
              | optional,
            ..
          },
      "definitions.StarlakeV1Base" =
        std.contract.Sequence
            [
              js2n.OneOf
                [
                  std.contract.any_of
                    [
                      js2n.Null,
                      Bool,
                      Number,
                      String,
                      js2n.record.Required [ "extract" ],
                      Array Dyn
                    ],
                  std.contract.any_of
                    [
                      js2n.Null,
                      Bool,
                      Number,
                      String,
                      js2n.record.Required [ "load" ],
                      Array Dyn
                    ],
                  std.contract.any_of
                    [
                      js2n.Null,
                      Bool,
                      Number,
                      String,
                      js2n.record.Required [ "transform" ],
                      Array Dyn
                    ],
                  std.contract.any_of
                    [
                      js2n.Null,
                      Bool,
                      Number,
                      String,
                      js2n.record.Required [ "env" ],
                      Array Dyn
                    ],
                  std.contract.any_of
                    [
                      js2n.Null,
                      Bool,
                      Number,
                      String,
                      js2n.record.Required [ "types" ],
                      Array Dyn
                    ],
                  std.contract.any_of
                    [
                      js2n.Null,
                      Bool,
                      Number,
                      String,
                      js2n.record.Required [ "tables" ],
                      Array Dyn
                    ],
                  std.contract.any_of
                    [
                      js2n.Null,
                      Bool,
                      Number,
                      String,
                      js2n.record.Required [ "table" ],
                      Array Dyn
                    ],
                  std.contract.any_of
                    [
                      js2n.Null,
                      Bool,
                      Number,
                      String,
                      js2n.record.Required [ "task" ],
                      Array Dyn
                    ],
                  std.contract.any_of
                    [
                      js2n.Null,
                      Bool,
                      Number,
                      String,
                      js2n.record.Required [ "application" ],
                      Array Dyn
                    ],
                  std.contract.any_of
                    [
                      js2n.Null,
                      Bool,
                      Number,
                      String,
                      js2n.record.Required [ "refs" ],
                      Array Dyn
                    ],
                  std.contract.any_of
                    [
                      js2n.Null,
                      Bool,
                      Number,
                      String,
                      js2n.record.Required [ "dag" ],
                      Array Dyn
                    ]
                ],
              {
                application
                  | refs_."definitions.AppConfigV1"
                  | { _ | Dyn }
                  | optional,
                dag
                  | refs_."definitions.DagGenerationConfigV1"
                  | { _ | Dyn }
                  | optional,
                env | refs_."definitions.MapString" | { _ | Dyn } | optional,
                extract
                  | js2n.OneOf
                    [
                      std.contract.Sequence
                        [ refs_."definitions.JDBCSchemasV1", { _ | Dyn } ],
                      std.contract.Sequence
                        [ refs_."definitions.OpenAPIsV1", { _ | Dyn } ]
                    ]
                  | optional,
                load | refs_."definitions.DomainV1" | { _ | Dyn } | optional,
                refs
                  | Array (
                    std.contract.Sequence
                      [ refs_."definitions.RefV1", { _ | Dyn } ]
                  )
                  | optional,
                table | refs_."definitions.TableV1" | { _ | Dyn } | optional,
                task
                  | refs_."definitions.AutoTaskDescV1"
                  | { _ | Dyn }
                  | optional,
                transform
                  | refs_."definitions.AutoJobDescV1"
                  | { _ | Dyn }
                  | optional,
                types
                  | Array (
                    std.contract.Sequence
                      [ refs_."definitions.TypeV1", { _ | Dyn } ]
                  )
                  | optional,
                ..
              }
            ],
      "definitions.TableDdlV1" =
        {
            createSql
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "SQL CREATE DDL statement",
            pingSql
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc m%"
                How to test if the table exist.
                Use the following statement by default: 'select count(*) from tableName where 1=0'
              "%
              | optional,
            selectSql
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "Override the default select defined by Starlake"
              | optional,
            ..
          },
      "definitions.TableTypeBase" =
        std.contract.Sequence
            [
              js2n.OneOf
                [
                  js2n.Const "TABLE",
                  js2n.Const "VIEW",
                  js2n.Const "SYSTEM TABLE",
                  js2n.Const "MATERIALIZED VIEW",
                  js2n.Const "GLOBAL TEMPORARY",
                  js2n.Const "LOCAL TEMPORARY",
                  js2n.Const "ALIAS",
                  js2n.Const "SYNONYM"
                ],
              refs_."definitions.ConvertibleToString",
              std.contract.any_of [ js2n.Null, Bool, Number, String ]
            ],
      "definitions.TableTypeV1" =
        std.contract.Sequence
            [
              js2n.OneOf
                [
                  std.contract.Sequence
                    [
                      refs_."definitions.TableTypeBase",
                      std.contract.any_of [ js2n.Null, Bool, Number, String ]
                    ],
                  std.contract.Sequence
                    [
                      std.contract.not
                        (std.contract.Sequence
                          [
                            refs_."definitions.TableTypeBase",
                            std.contract.any_of
                              [ js2n.Null, Bool, Number, String ]
                          ]),
                      refs_."definitions.ConvertibleToString",
                      std.contract.any_of [ js2n.Null, Bool, Number, String ]
                    ]
                ],
              refs_."definitions.ConvertibleToString",
              std.contract.any_of [ js2n.Null, Bool, Number, String ]
            ],
      "definitions.TableV1" =
        {
            acl
              | Array (
                std.contract.Sequence
                  [ refs_."definitions.AccessControlEntryV1", { _ | Dyn } ]
              )
              | doc "Map of rolename -> List[Users]."
              | optional,
            attributes
              | Array (
                std.contract.Sequence
                  [ refs_."definitions.AttributeV1", { _ | Dyn } ]
              )
              | doc "Attributes parsing rules.",
            comment
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "free text"
              | optional,
            expectations
              | Array (
                std.contract.Sequence
                  [ refs_."definitions.ExpectationItemV1", { _ | Dyn } ]
              )
              | doc "Expectations to check after Load / Transform has succeeded"
              | optional,
            filter
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "remove all records that do not match this condition"
              | optional,
            metadata
              | refs_."definitions.MetadataV1"
              | { _ | Dyn }
              | doc "Dataset metadata"
              | optional,
            name
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc m%"
                Schema name, must be unique among all the schemas belonging to the same domain.
                  *                     Will become the hive table name On Premise or BigQuery Table name on GCP.
              "%,
            pattern
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc m%"
                filename pattern to which this schema must be applied.
                  *                     This instructs the framework to use this schema to parse any file with a filename that match this pattern.
              "%,
            patternSample
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "Sample of filename matching this schema"
              | optional,
            postsql
              | Array (
                std.contract.Sequence
                  [
                    refs_."definitions.ConvertibleToString",
                    std.contract.any_of [ js2n.Null, Bool, Number, String ]
                  ]
              )
              | doc "Reserved for future use."
              | optional,
            presql
              | Array (
                std.contract.Sequence
                  [
                    refs_."definitions.ConvertibleToString",
                    std.contract.any_of [ js2n.Null, Bool, Number, String ]
                  ]
              )
              | doc "Reserved for future use."
              | optional,
            primaryKey
              | Array (
                std.contract.Sequence
                  [
                    refs_."definitions.ConvertibleToString",
                    std.contract.any_of [ js2n.Null, Bool, Number, String ]
                  ]
              )
              | doc "List of columns that make up the primary key"
              | optional,
            rename
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "If present, the table is renamed with this name. Useful when use in conjunction with the 'extract' module"
              | optional,
            rls
              | Array (
                std.contract.Sequence
                  [ refs_."definitions.RowLevelSecurityV1", { _ | Dyn } ]
              )
              | doc " Row level security on this schema."
              | optional,
            sample
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "Store here a couple of records illustrating the table data."
              | optional,
            streams
              | Array (
                std.contract.Sequence
                  [
                    refs_."definitions.ConvertibleToString",
                    std.contract.any_of [ js2n.Null, Bool, Number, String ]
                  ]
              )
              | doc "attach streams to table (Snowflake only)"
              | optional,
            tags
              | Array (
                std.contract.Sequence
                  [
                    refs_."definitions.ConvertibleToString",
                    std.contract.any_of [ js2n.Null, Bool, Number, String ]
                  ]
              )
              | doc "Set of string to attach to this Schema"
              | optional,
            ..
          },
      "definitions.TrimV1" =
        std.contract.Sequence
            [
              js2n.OneOf
                [
                  js2n.Const "LEFT",
                  js2n.Const "RIGHT",
                  js2n.Const "BOTH",
                  js2n.Const "NONE"
                ],
              refs_."definitions.ConvertibleToString",
              std.contract.any_of [ js2n.Null, Bool, Number, String ]
            ],
      "definitions.TypeV1" =
        {
            comment
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "Describes this type"
              | optional,
            ddlMapping
              | refs_."definitions.MapString"
              | { _ | Dyn }
              | doc "Configure here the type mapping for each datawarehouse.\\nWill be used when inferring DDL from schema."
              | optional,
            name
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "unique id for this type",
            pattern
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "Regex used to validate the input field",
            primitiveType
              | refs_."definitions.PrimitiveTypeV1"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc m%"
                To what primitive type should this type be mapped.
                 This is the memory representation of the type, When saving, this primitive type is mapped to the database specific type. Default: string
              "%
              | optional,
            sample
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "This field makes sure that the pattern matches the value you want to match. This will be checked on startup"
              | optional,
            zone
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc m%"
                useful when parsing specific string:
                 - double: To parse a french decimal (comma as decimal separator) set it to fr_FR locale.
                - decimal: to set the precision and scale of this number, '38,9' by default.
                - 
              "%
              | optional,
            ..
          },
      "definitions.WriteStrategyTypeBase" =
        std.contract.Sequence
            [
              js2n.OneOf
                [
                  js2n.Const "OVERWRITE",
                  js2n.Const "APPEND",
                  js2n.Const "UPSERT_BY_KEY",
                  js2n.Const "UPSERT_BY_KEY_AND_TIMESTAMP",
                  js2n.Const "DELETE_THEN_INSERT",
                  js2n.Const "SCD2",
                  js2n.Const "OVERWRITE_BY_PARTITION"
                ],
              refs_."definitions.ConvertibleToString",
              std.contract.any_of [ js2n.Null, Bool, Number, String ]
            ],
      "definitions.WriteStrategyV1" =
        {
            endTs
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "TODO"
              | optional,
            key
              | Array (
                std.contract.Sequence
                  [
                    refs_."definitions.ConvertibleToString",
                    std.contract.any_of [ js2n.Null, Bool, Number, String ]
                  ]
              )
              | doc "TODO"
              | optional,
            on | refs_."definitions.MergeOnV1" | doc "TODO" | optional,
            queryFilter
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "TODO"
              | optional,
            startTs
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "TODO"
              | optional,
            timestamp
              | refs_."definitions.ConvertibleToString"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "TODO"
              | optional,
            type
              | refs_."definitions.OpenWriteStrategyTypeV1"
              | std.contract.any_of [ js2n.Null, Bool, Number, String ]
              | doc "TODO"
              | optional,
            types
              | {
                _ | std.contract.Sequence
                  [
                    refs_."definitions.OpenWriteStrategyTypeV1",
                    std.contract.any_of [ js2n.Null, Bool, Number, String ]
                  ]
              }
              | doc "TODO"
              | optional,
            ..
          },
    }
    in
  std.contract.Sequence
      [
        refs_."definitions.StarlakeV1Base",
        { version | std.number.Integer | js2n.Enum [ 1 ], .. }
      ]